МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
Кафедра «Програмна інженерія»




ЗВІТ
з практичної роботи
з дисципліни «Аналіз та рефакторінг коду»
на тему «Керівництво з оформлення та стилю коду на мові JavaScript за стандартами Airbnb та jQuery.»




Виконала:
ст. гр. ПЗПІ-23-10
Сергєєва Т. Д.


Перевірив:
Старший викл. Кафедри ПІ
Сокорчук І. П.




Харків 2025
1. ІСТОРІЯ ЗМІН
№ДатаВерсія звітуОпис змін та виправлень101.10.250.1Створено розділ “Опис виконаної роботи”205.10.250.1Створено додаток а, додаток б.310.10.250.1Створено розділи “Історія змін”, “Завдання”, “Висновки”420.10.250.1Створено додаток в.      


2. ЗАВДАННЯ
      Завданням моєї роботи є ознайомлення з основними принципами написання якісного та зрозумілого коду на мові програмування JavaScript, а також формування практичних навичок його застосування. Я прагну показати, наскільки важливо використовувати сучасні можливості мови, такі як ES6+, асинхронність, модулі та нові структури даних. Це допоможе розробникам уникати типових помилок, підвищувати читабельність коду, робити його безпечнішим і легшим для подальшої підтримки. Крім того, мета полягає у тому, щоб навчитися структурувати програмний код, правильно застосовувати інструменти оптимізації та організації проєктів, що є необхідною складовою підготовки майбутніх фахівців з інженерії програмного забезпечення.



3. ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Вступ
      Тема моєї доповіді – основні рекомендації написання коду на JavaScript. Чому саме ця тема є важливою? JavaScript уже багато років залишається однією з найпопулярніших мов програмування у світі. Його універсальність робить його незамінним у різних сферах: від фронтенд-розробки, де він використовується для створення динамічних інтерфейсів у браузерах, до бекенд-програмування на сервері, наприклад з використанням Node.js. JavaScript сьогодні застосовується також у створенні мобільних додатків, настільних програм і навіть у роботі з апаратними пристроями, такими як мікроконтролери. Але сама по собі мова – це лише інструмент. Важливіше, як саме ми його використовуємо. Адже один і той самий функціонал можна реалізувати десятками різних способів, але лише частина з них буде справді якісною, читабельною й зручною для подальшої підтримки. Код – це, по суті, текст, який ми пишемо для комп’ютера, але читають його насамперед люди: інші програмісти, члени команди, або навіть ми самі через кілька місяців. Якщо цей текст незрозумілий, хаотичний і не має структури, то він перетворюється на проблему. Тому тема «чистого коду» настільки актуальна. У своїй доповіді я хочу показати основні принципи, які допоможуть зробити JavaScript-код зрозумілим, логічним і професійним.
3.2 Читабельність коду та назви змінних
      Перше й головне правило гарного програмування – код повинен бути читабельним. Дуже часто новачки вважають, що можна називати змінні як завгодно, аби тільки програма працювала. Але в реальності саме назви змінних і функцій визначають, наскільки легко можна зрозуміти програму. Уявіть, що у вас є змінна з назвою “x”. Чи зрозуміє людина, яка читає ваш код, що в ній зберігається? Можливо, там вік користувача, можливо, ціна товару, а можливо, зовсім інше значення. Для людини, яка бачить цей код уперше, це стане загадкою. А тепер уявіть, що замість «x» ви написали userAge або maxUsers. (Див. додаток В.1)
       У такому випадку навіть без коментарів зрозуміло, що це за дані. Назви змінних – це, по суті, міні-документація вашої програми. Чим вони чіткіші, тим менше шансів на помилки й тим швидше можна розібратися в логіці роботи. Особливо це важливо в командній розробці, де над одним проєктом працюють кілька людей. Якщо кожен буде вигадувати дивні скорочення чи незрозумілі позначення, то проект перетвориться на хаос. Тому одна з головних порад – давати змінним і функціям осмислені й зрозумілі назви, які відображають їхній зміст і призначення.
3.3 Const, let та var
      У JavaScript є три способи оголосити змінну: var, let та const. (Див. додаток В.2) Історично найстаріший – це var. Його особливість у тому, що він має поведінку, яка називається «підняттям оголошення» або hoisting. Це означає, що змінна, оголошена через var, «ніби переноситься» на початок блоку чи функції. У результаті можна отримати дуже дивні ситуації: змінна використовується до того, як вона була оголошена, і це не викликає помилки. Для новачків це особливо небезпечно, бо програма працює непередбачувано. Саме тому сучасна практика відмовилася від var і використовує let та const. Якщо у вас є значення, яке може змінюватися під час виконання програми, краще застосувати let. Наприклад, якщо ви ведете підрахунок очок у грі. Якщо ж ви задаєте константу, яка не повинна змінюватися, наприклад число Пі чи максимальна кількість користувачів, то доречно використати const. Це робить код більш логічним і безпечним: ви одразу бачите, де значення є незмінним, а де воно може змінюватися. Такий підхід допомагає уникнути випадкових багів і робить код передбачуваним для всієї команди. 
3.4  Форматування та відступи
      Форматування – це «зовнішній вигляд» вашого коду. Можливо, ви бачили приклади програм, де всі рядки написані підряд, без відступів, пробілів і з хаотичним розташуванням дужок. Такий код виглядає як «суп із літер» і дуже важко зрозуміти, що в ньому відбувається. Уявіть собі роман чи підручник, де немає абзаців і розділів – він був би практично непридатний для читання. Те саме і з програмами. Гарне форматування з відступами, однаковими пробілами, акуратно розставленими дужками допомагає розбивати код на логічні частини (Див. додаток В.3).. Це робить його не лише зручним для читання, а й для підтримки. Особливо важливо це для великих проектів, які можуть мати тисячі чи навіть мільйони рядків коду. Якщо кожен програміст у команді буде писати у своєму стилі, то вийде хаос Саме тому у професійних командах завжди застосовують єдиний стиль форматування. Це дозволяє всім учасникам проекту швидко розуміти чужий код і працювати більш ефективно.
      2.5 Строге і нестроге порівняння
      Однією з особливостей JavaScript є наявність двох операторів порівняння: == та ===. На перший погляд вони схожі, але різниця між ними дуже велика. Оператор == виконує так зване нестроге порівняння. Це означає, що перед перевіркою значення автоматично приводяться до одного типу. У результаті можуть виникати дивні результати. Наприклад, якщо ви порівняєте число 5 і рядок '5', отримаєте true (Див. додаток В.4). Для комп’ютера це «нормально», але для програміста така поведінка може стати несподіванкою й призвести до помилок. У складних програмах це взагалі може стати причиною серйозних багів, які дуже важко знайти. Саме тому у професійній практиці рекомендується завжди використовувати потрійне дорівнює, тобто оператор ===. Він виконує строге порівняння: перевіряє не лише значення, а й тип змінних. У такому випадку 5 === '5' поверне false, що є більш логічним і зрозумілим. Такий підхід дозволяє уникати «підводних каменів» JavaScript і робить ваш код надійнішим.
2.6 Принцип DRY (Don’t Repeat Yourself)
      Одна з основних проблем у програмуванні – повторення однакових фрагментів коду в різних місцях програми. Це називають дублюванням коду, і воно серйозно ускладнює підтримку проєкту. Кожна копія коду – це потенційне джерело помилок. Якщо логіка змінюється, потрібно редагувати її у всіх місцях, де вона повторюється, що дуже легко забути. У результаті програма стає важко підтримуваною і небезпечною. Щоб уникнути цього, рекомендується виділяти повторювані фрагменти в окремі функції чи методи (Див. додаток В.5). Такий підхід робить код компактнішим, легшим для читання, і будь-які зміни в логіці потрібно робити лише в одному місці. Крім того, це сприяє повторному використанню коду і спрощує тестування, оскільки одна функція перевіряється окремо і гарантує коректність результатів у всіх випадках використання.
2.7 Використання сучасних можливостей ES6+
      Сучасний JavaScript пропонує безліч нових можливостей, які роблять код більш зручним і читабельним. Починаючи з ECMAScript 2015 (ES6) і пізніших версій, у мові з’явився синтаксис, який дозволяє писати коротші та зрозуміліші вирази. Стрілкові функції, наприклад, скорочують запис функцій і роблять код компактнішим (Див. додаток В.6). Шаблонні рядки дозволяють легко вставляти змінні та вирази всередину тексту без громіздкого конкатенування рядків. Крім того, ES6+ вводить деструктуризацію об’єктів і масивів, оператори поширення (...), класи, модулі import/export, а також параметри за замовчуванням у функціях. Наступні версії, як ES7–ES11, додають async/await для зручної роботи з асинхронним кодом, оператор піднесення до степеня **, нові методи масивів, об’єкти Map і Set, BigInt, optional chaining ?. тощо. Використання сучасних можливостей мови не лише скорочує обсяг коду, а й зменшує кількість помилок, підвищує ефективність роботи та робить код більш зрозумілим для команди.
2.8 Умовні оператори та короткі записи
      Коли ми працюємо з умовами в JavaScript, часто доводиться використовувати конструкції if…else для перевірки різних варіантів виконання. Проте в багатьох випадках, коли умова проста, можна скоротити запис за допомогою тернарного оператора. Це робить код компактнішим і зручнішим для читання. Наприклад, замість довгої конструкції if…else можна записати умову в один рядок і відразу присвоїти змінній потрібне значення. Важливо пам’ятати, що надмірне використання тернарного оператора для складних умов може погіршити читабельність коду, тому завжди слід балансувати між компактністю та зрозумілістю (Див. додаток В.7).
2.9 Деструктуризація об’єктів та масивів
      Деструктуризація об’єктів та масивів у JavaScript – це потужний і дуже зручний інструмент, який значно спрощує роботу з даними. Вона дозволяє «розпаковувати» властивості об’єктів або елементи масивів у окремі змінні, не повторюючи звернення до цих даних через звичайну точкову нотацію. Наприклад, у типовій ситуації без деструктуризації, щоб отримати значення name та age користувача, доводиться писати user.name і user.age у різних місцях коду, що робить його довшим і менш читабельним, особливо якщо таких звернень багато. З деструктуризацією ж можна одразу «витягнути» ці значення у змінні за один рядок коду: const { name, age } = user (Див. додаток В.8). Таким чином, код стає більш компактним і зрозумілим, адже відразу видно, які дані використовуються, без необхідності повторно переглядати структуру об’єкта. Крім того, деструктуризація допомагає зменшити дублювання коду і спрощує його підтримку. Якщо об’єкт або масив містить багато властивостей, можна вибрати лише потрібні, не зачіпаючи решту, що робить роботу з великими структурами даних більш ефективною. Деструктуризація також підтримує вкладені об’єкти, дозволяючи «розпаковувати» дані на декількох рівнях одночасно. Крім об’єктів, деструктуризація ефективно працює і з масивами: можна присвоїти елементи масиву окремим змінним, швидко змінювати порядок або пропускати непотрібні елементи.
2.10 Обробка помилок
      Обробка помилок у JavaScript – це важлива частина написання якісного та надійного коду. Оскільки JavaScript є динамічною мовою програмування, помилки можуть виникати в будь-який момент виконання програми, особливо при взаємодії з зовнішніми даними, API-запитами або роботою з файлами та базами даних. Якщо не передбачити можливість помилок, програма може несподівано зупинитися, що призведе до непередбачуваної поведінки або втрати даних. Щоб уникнути таких ситуацій і забезпечити стабільність програми, використовується конструкція try…catch, яка дозволяє «перехоплювати» помилки під час виконання коду (Див. додаток В.9).
      Блок try містить код, який потенційно може викликати помилку, а блок catch визначає дії, що виконуються у разі виникнення цієї помилки. Наприклад, у catch можна вивести повідомлення для користувача, зберегти деталі помилки у лог-файл або відновити роботу програми в безпечному режимі. Це дозволяє не лише уникнути аварійного завершення роботи програми, але й зробити її більш передбачуваною та керованою. Крім того, обробка помилок допомагає розробникам відслідковувати й усувати проблеми, адже вони отримують інформацію про тип помилки, місце її виникнення та стан програми на момент збою.
2.11 Коментарі
      Коментарі у JavaScript – це важливий інструмент для пояснення логіки коду, який дозволяє розробникам швидко зрозуміти, що відбувається у програмі та чому було прийнято те чи інше рішення. Вони не повинні дублювати очевидні дії коду, наприклад, не варто писати «збільшуємо значення на 1» біля рядка count++, адже це очевидно з самого коду. Натомість коментарі мають пояснювати складні алгоритми, нетипову логіку, причини використання певних методів або особливості роботи з даними. Це особливо корисно у великих проєктах та при командній розробці, коли над кодом працює багато людей, і кожен має швидко розуміти, як працює певна частина програми. Одним із сучасних і стандартних способів коментування у JavaScript є JSDoc. JSDoc дозволяє додавати структуровані коментарі до функцій, класів, змінних та модулів, з яких потім можна автоматично генерувати документацію. Коментарі у форматі JSDoc починаються з /** … */ і містять спеціальні теги, які описують параметри функції, її повертаємі значення, винятки та інші важливі характеристики (Див. додаток В.10). Наприклад, тег @param описує тип і призначення аргументу функції, @returns – що повертає функція, а @example дозволяє навести приклад використання. Використання JSDoc має кілька суттєвих переваг. По-перше, сучасні IDE, такі як Visual Studio Code, можуть автоматично показувати підказки щодо функцій, їх параметрів і типів даних на основі коментарів JSDoc, що значно спрощує роботу з кодом. По-друге, з таких коментарів можна генерувати повноцінну документацію для проєкту у вигляді HTML або PDF, що полегшує передачу знань у команді та підтримку коду у довгостроковій перспективі. Крім того, використання JSDoc робить тестування більш прозорим і допомагає новим розробникам швидше орієнтуватися в проєкті.
2.12 Уникання магічних чисел
      Магічні числа – це числові значення, які з’являються у коді без пояснення свого сенсу або призначення. Вони називаються «магічними», бо інший розробник, який читає код, не завжди зрозуміє, чому саме використано це число і що воно означає. Використання магічних чисел робить код менш зрозумілим, підвищує ризик помилок і ускладнює підтримку програмного забезпечення. Наприклад, якщо в програмі зустрічається рядок let discountedPrice = 500 * 0.4;, не зовсім ясно, чому саме 0.4 використовується для розрахунку ціни – це може бути знижка, комісія або ще щось (Див. додаток В.11). Щоб зробити код більш зрозумілим і легким для підтримки, рекомендується замінювати магічні числа на константи з описовими назвами. Це дозволяє пояснити значення числа прямо у коді і легко змінювати його у майбутньому, якщо параметри програми зміняться.  У цьому прикладі стає абсолютно зрозуміло, що 0.4 – це відсоток знижки, а не довільне число. Такий підхід підвищує читабельність коду, робить його більш логічним і зменшує ймовірність помилок при внесенні змін. Якщо завтра потрібно змінити розмір знижки, достатньо змінити значення DISCOUNT_RATE в одному місці, і код автоматично буде працювати з новою знижкою по всій програмі.
2.13 Асинхронність у JS
      JavaScript – це однопоточна мова програмування, що означає, що всі команди виконуються послідовно, рядок за рядком, у тому порядку, в якому вони записані. У більшості випадків цього достатньо, але інколи деякі операції можуть займати значний час, наприклад завантаження даних із сервера, читання файлів або обробка великих масивів. Якщо виконувати такі операції синхронно, весь код «зависне», тобто програма перестане реагувати, поки не завершиться довга задача. Це може призвести до зависання інтерфейсу користувача або затримок у роботі програми, що особливо критично для веб-застосунків, де швидкість відгуку є ключовою. Щоб уникнути блокування виконання і дозволити програмі продовжувати роботу під час очікування довгих операцій, у JavaScript використовують асинхронність. Асинхронність дозволяє запускати тривалі завдання у фоновому режимі та отримувати результат пізніше, не зупиняючи весь потік виконання. Основними інструментами для цього є проміси (Promise) та ключові слова async і await (Див. додаток В.12). Promise – це спеціальний об’єкт у JavaScript, який «обіцяє» надати результат у майбутньому. У проміса є три стани: pending – очікування виконання. Проміс створено, але результат ще не готовий. fulfilled – успішне виконання. Проміс повернув результат без помилок. rejected – відмова або помилка. Проміс завершився з помилкою, яку можна обробити. Уявіть проміс як замовлення в інтернет-магазині: ви оформили покупку, магазин обробляє її у фоновому режимі (pending), потім товар доставлено (fulfilled) або сталася проблема з доставкою (rejected). Проміси дозволяють обробляти ці ситуації за допомогою методів .then() для успішного завершення та .catch() для помилок. Async/await – це сучасний синтаксичний інструмент, який значно спрощує роботу з асинхронним кодом. Функція, позначена ключовим словом async, завжди повертає проміс. Використовуючи ключове слово await всередині такої функції, ми «чекаємо» завершення проміса і отримуємо його результат без необхідності писати довгі ланцюжки .then() та .catch(). Це дозволяє писати асинхронний код так, ніби він синхронний, що значно підвищує його читабельність і зменшує ризик помилок.
2.14 Модулі та структура кода
      Модулі в JavaScript – це один із ключових механізмів для організації коду та розподілу його на логічні частини. У великих проєктах код часто стає громіздким і важким для розуміння, особливо якщо всі функції, класи та дані знаходяться в одному файлі. Використання модулів дозволяє розбивати програму на окремі файли, кожен з яких відповідає за свою частину логіки. Це значно полегшує роботу над проєктом, робить його структуру більш зрозумілою і дозволяє ефективно масштабувати програму. Головна перевага модулів полягає в повторному використанні коду. Один модуль можна підключати в різних частинах програми, що дозволяє не дублювати однакову логіку та зменшує ризик помилок. Крім того, модулі підвищують безпеку коду, оскільки дані та функції, які не потрібно використовувати поза модулем, можна зробити приватними. Це забезпечує інкапсуляцію та зменшує ймовірність випадкових змін глобальних змінних. У JavaScript для роботи з модулями використовують ключові слова import та export. За допомогою export ми вказуємо, які частини коду з модуля будуть доступні зовні, а import дозволяє підключати ці частини у інших файлах (Див. додаток В.13). Такий підхід робить код більш структурованим і легким для розуміння навіть для людей, які приєдналися до проєкту пізніше. Крім того, модулі сприяють кращому тестуванню: окремий модуль можна протестувати ізольовано, не впливаючи на решту коду.
2.15 Мар та Set
      У JavaScript є сучасні структури даних – Map і Set, які значно спрощують роботу з колекціями та дозволяють ефективніше організовувати дані порівняно зі звичайними масивами чи об’єктами. Set – це колекція, яка зберігає лише унікальні значення. Це означає, що однакові елементи не можуть повторюватися. Використання Set особливо корисне, коли потрібно швидко прибрати дублікати з масиву або відстежувати унікальні елементи, наприклад, у списку користувачів або тегів. Крім того, Set зберігає порядок додавання елементів, що дозволяє зручно перераховувати елементи у циклах. Set має такі методи, як add() для додавання нового елемента, delete() для видалення, has() для перевірки наявності елемента, clear() для очищення всієї колекції, а також властивість size для визначення кількості елементів. Map, у свою чергу, – це колекція пар ключ – значення, яка дає більше можливостей порівняно зі звичайними об’єктами. У Map ключами можуть бути не тільки рядки або числа, а й об’єкти, функції або будь-які інші типи. Це робить Map гнучкішим для зберігання складних даних. Крім того, Map зберігає порядок додавання елементів, що дозволяє обходитись у циклах у тій же послідовності, у якій вони були додані. Map має методи set() для додавання або оновлення значення за ключем, get() для отримання значення, has() для перевірки наявності ключа, delete() для видалення елемента, clear() для очищення всієї колекції та властивість size для визначення кількості елементів у колекції (Див. додаток В.14).
      2.16 Інструменти для перевірки стилю
      У сучасній розробці особливу увагу приділяють якості коду. Це важливо не лише для того, щоб код працював правильно, а й для того, щоб його було легко читати, підтримувати та масштабувати, особливо коли над проєктом працює команда розробників. У великих командах у різних людей можуть бути різні звички написання коду: хтось любить вкладені відступи в два пробіли, хтось – у чотири; хтось ставить крапки з комою після кожного рядка, хтось – ні. Якщо ці стилі змішуються в одному проєкті, код стає важким для сприйняття, підвищується ймовірність помилок і уповільнюється командна робота. Щоб уникнути цих проблем, використовують спеціальні інструменти для перевірки стилю та автоматичного форматування коду. Найпопулярніші серед них – ESLint і Prettier (Див. додаток В.15). ESLint – це статичний аналізатор коду для JavaScript і TypeScript, який дозволяє перевіряти код на дотримання правил стилю, синтаксичні помилки та потенційні баги ще до запуску програми. Використання ESLint допомагає підтримувати чистоту коду, уникати логічних помилок і забезпечує більш структуровану роботу над проєктом. Основні можливості цього інструменту включають перевірку стилю коду, що охоплює правильне використання пробілів, лапок та відступів, а також виявлення помилок, наприклад, змінних, які оголошені, але не використовуються, або потенційно небезпечних конструкцій. ESLint є висококонфігурованим: його можна налаштувати під будь-які потреби проєкту через конфігураційний файл, де визначаються правила стилю, заборонені конструкції та рівень суворості перевірки. Крім того, ESLint інтегрується з популярними редакторами коду, такими як Visual Studio Code, що дозволяє відразу підсвічувати помилки та попередження під час написання коду. Prettier – це інструмент для автоматичного форматування коду, який не аналізує логіку, а забезпечує єдиний та акуратний стиль написання коду, роблячи його більш читабельним і структурованим. Використання Prettier дозволяє команді уникати суперечок щодо відступів, форматування рядків, лапок або структури об’єктів і масивів, оскільки всі учасники дотримуються одного стандарту. Prettier автоматично приводить код до єдиного стилю, розставляє відступи, переносить довгі рядки, правильно форматуючи функції, масиви та об’єкти, що суттєво підвищує зручність читання та підтримки коду. Інтеграція Prettier можлива як у редакторі коду, так і на етапі збірки проєкту через npm-скрипти або Git hooks, що дозволяє автоматично форматувати код перед комітами та підтримувати його акуратним у будь-який момент розробки. Разом ESLint і Prettier створюють потужний набір інструментів для забезпечення якості коду, поєднуючи перевірку логіки, стилю та автоматичне форматування.
      2.17 Unit-тести та TDD у JS
      Unit-тести та підхід TDD є важливими складовими якісної розробки програмного забезпечення на JavaScript, оскільки вони дозволяють перевіряти роботу окремих компонентів коду ще на ранніх етапах розробки та забезпечують високу надійність програми. Юніт-тестування, або unit testing, передбачає створення тестів для невеликих одиниць коду – функцій, класів або модулів – з метою впевненості, що кожен елемент працює відповідно до очікувань. Такий підхід дозволяє швидко виявляти помилки, спрощує внесення змін у код і знижує ризик того, що нові зміни випадково порушать роботу вже існуючого функціоналу. Unit-тести допомагають структуровано підходити до розробки, роблять процес підтримки та рефакторингу більш передбачуваним і забезпечують зручну документацію щодо очікуваної поведінки окремих частин програми. Test-Driven Development (TDD) – це методика розробки, яка передбачає написання тестів перед створенням основного коду. Основна ідея TDD полягає в тому, щоб спочатку визначити очікувану поведінку функції чи модуля у вигляді тесту, який спершу не проходить, а потім написати мінімальний код, необхідний для успішного проходження цього тесту. Після цього код оптимізується, а тест повторно запускається, щоб переконатися у правильності змін. Такий підхід дозволяє розробникам дисципліновано будувати проєкт, уникати зайвих багів і створювати більш надійний та прогнозований код. Для JavaScript існують популярні фреймворки та інструменти, які спрощують роботу з юніт-тестами і TDD, зокрема Jest та Mocha (Див. додаток В.16). Jest – це сучасний фреймворк для тестування, розроблений компанією Facebook (Meta), який пропонує "все в одному": запуск тестів, assertion-бібліотеку для перевірки результатів та інструменти для створення моків і симуляцій. Його перевага полягає у простоті використання та інтеграції з популярними бібліотеками, такими як React, що робить Jest зручним вибором для сучасних веб-проєктів. Mocha, у свою чергу, є більш гнучким і старішим фреймворком для тестування у JavaScript, який дозволяє будувати тести за допомогою ключових слів describe та it. Для перевірки результатів у Mocha часто застосовують бібліотеки assert або chai, що надає додаткові можливості для тестування різних аспектів коду. Обидва фреймворки підтримують TDD і сприяють створенню чистого, стабільного та перевіреного коду, дозволяючи командам розробників впевнено масштабувати проєкти та забезпечувати їхню якість на високому рівні.

4. ВИСНОВКИ
       У підсумку, дотримання правил чистого та сучасного програмування у JavaScript – це не просто набір рекомендацій, а фундамент для створення якісного, надійного та підтримуваного коду. Читабельність коду та зрозумілі назви змінних допомагають швидко орієнтуватися в логіці програми та знижують ризик помилок, особливо в командних проєктах. Використання let та const замість застарілого var робить код передбачуваним і безпечним, тоді як форматування та відступи забезпечують його структурованість і легкість сприйняття. Принцип DRY, уникання магічних чисел, використання сучасних можливостей ES6+ та деструктуризація об’єктів і масивів дозволяють писати компактний та ефективний код, який легко підтримувати і тестувати. Асинхронність із застосуванням промісів та async/await забезпечує плавну роботу програм, не блокуючи основний потік, а модулі й правильна організація структури коду сприяють масштабованості та повторному використанню компонентів. Map, Set, обробка помилок та коментарі у форматі JSDoc додають додаткову безпеку та зрозумілість, роблячи програму більш передбачуваною. Інструменти для перевірки стилю, такі як ESLint та Prettier, допомагають підтримувати єдиний стандарт коду, що критично важливо для командної розробки. Нарешті, впровадження unit-тестів та підхід TDD дозволяють створювати стабільний та надійний функціонал, впевнено виявляти й виправляти помилки на ранніх етапах і будувати програму, орієнтуючись на очікувану поведінку. Разом ці практики формують комплексний підхід до професійної розробки на JavaScript, що забезпечує не лише працездатність програми, а й її довгострокову підтримуваність, масштабованість та високу якість. Впроваджуючи ці принципи, розробник не тільки підвищує ефективність власної роботи, а й створює продукт, який буде зрозумілим, надійним і легким у супроводі для всієї команди.


5. СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ
      1. Coding Style. The Modern JavaScript Tutorial. URL: https://javascript.info/coding-style (date of access: 01.10.2025).
      2. Crockford D. Javascript: The Good Parts. O'Reilly Media, Incorporated, 2008.
      3. GitHub - airbnb/javascript: JavaScript Style Guide. GitHub. URL: https://github.com/airbnb/javascript (date of access: 01.10.2025).
      4. JavaScript manual of style. Emeryville, Calif : ZD Press, 1996. 277 p.
      5. JavaScript Style Guide | Contribute to jQuery. Contribute to jQuery. URL: https://contribute.jquery.org/style-guide/js/ (date of access: 01.10.2025).




ДОДАТОК А
Відеозапис
Відеозапис доповіді: https://www.youtube.com/watch?v=1Q_ejHmcvB8
Хронологічний опис відеозапису:
0:00 - Вступ 
0:16 - Читабільність коду та назви зміних, класів, тощо. 
0:42 - Const, let та var. 
1:04 - Форматування та відступи.
1:19 - Строге і нестроге порівняння. 
1:53 - Принцип DRY (Don`t repeat yourself). 
2:14 - Використання сучасних можливостей ES6+. 
2:43 - Умовні оператори та короткі записи. 
3:03 - Деструктуризація об'єктів та масивів. 
3:27 - Обробка помилок. 3:42 - Коментарі. 
4:13 - Уникання магічних чисел. 
4:26 - Асинхронність у JS. 
4:59 - Модулы та структура кода. 
5:14 - Map та Set. 
5:31 - Інструмеенти для перевірки стилю. 
5:57 - Unit-тести та TDD у JS. 
6:25 - Висновки. 
6:47 - Списки використаних джерел.

ДОДАТОК Б
Слайди презентації


Рисунок Б.1 – Титульний лист


Рисунок Б.2 – Вступ
      

Рисунок Б.3 – Назви змінних


Рисунок Б.4 – Оголошення змінних


Рисунок Б.5 – Форматування


Рисунок Б.6 – Порівняння


Рисунок Б.7 – Не дублювати код


Рисунок Б.8 – Сучасні можливості


Рисунок Б.9 – Умовні оператори


Рисунок Б.10 – Деструктуризація


Рисунок Б.11 – Помилки


Рисунок Б.12 – Коментарі


Рисунок Б.13 – Без магічних чисел


Рисунок Б.14 – Асинхронність


Рисунок Б.15 – Структура коду


Рисунок Б.16  – Map та Set

Рисунок Б.17 – Перевірка стилю


Рисунок Б.18 – Unit-тести та TDD

Рисунок Б.19 – Висновки


Рисунок Б.20 – Списки джерел


ДОДАТОК В
Програмний код
В.1 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NureKulabukhovaTaisiia/ark-pzpi-23-10-kulabukhova-taisiia/blob/main/Pract1/ark-pzpi-23-10-Serhiehieva-Taisiia-pract1/code-examples-code-conventions.js
1
2
3
4
5
6
7// Погано 
let x = 5; 
let y = 10;

// Добре
let userAge = 5;
let maxUsers = 10;

В.2 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NureKulabukhovaTaisiia/ark-pzpi-23-10-kulabukhova-taisiia/blob/main/Pract1/ark-pzpi-23-10-Serhiehieva-Taisiia-pract1/code-examples-code-conventions.js
 1
 2
 3 var oldVar = "старий"; // не рекомендується
 let userName = "Anna"; // змінна
 const PI = 3.14; // константа
 
 
В.3 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NureKulabukhovaTaisiia/ark-pzpi-23-10-kulabukhova-taisiia/blob/main/Pract1/ark-pzpi-23-10-Serhiehieva-Taisiia-pract1/code-examples-code-conventions.js
1
2
3
4
5// Погано
function sum(a,b){return a+b;}
// Добре
function sum(a, b) {
return a + b;
В.4 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NureKulabukhovaTaisiia/ark-pzpi-23-10-kulabukhova-taisiia/blob/main/Pract1/ark-pzpi-23-10-Serhiehieva-Taisiia-pract1/code-examples-code-conventions.js
1
2  console.log(5 == "5"); // true
  console.log(5 === "5");  // false
  
В.5 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NureKulabukhovaTaisiia/ark-pzpi-23-10-kulabukhova-taisiia/blob/main/Pract1/ark-pzpi-23-10-Serhiehieva-Taisiia-pract1/code-examples-code-conventions.js
1
2
3
4
5// Погано
console.log("Hello");
console.log("Hello");
// Добре
function greet() { console.log("Hello"); } greet();

В.6 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NureKulabukhovaTaisiia/ark-pzpi-23-10-kulabukhova-taisiia/blob/main/Pract1/ark-pzpi-23-10-Serhiehieva-Taisiia-pract1/code-examples-code-conventions.js
1
2
3
4
5
6//Старе
function add(a, b) {
  return a + b;
}
//Нове
const add = (a, b) => a + b;

В.7 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NureKulabukhovaTaisiia/ark-pzpi-23-10-kulabukhova-taisiia/blob/main/Pract1/ark-pzpi-23-10-Serhiehieva-Taisiia-pract1/code-examples-code-conventions.js
1
2
3
4const isLoggedIn = true;
const message = isLoggedIn ? "Ви в системі" : "Будь ласка, увійдіть";

console.log(message);

В.8 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NureKulabukhovaTaisiia/ark-pzpi-23-10-kulabukhova-taisiia/blob/main/Pract1/ark-pzpi-23-10-Serhiehieva-Taisiia-pract1/code-examples-code-conventions.js
1
2
3
4
5
6
7const user = {name: "Anna", age: 20};
const {name, age} = user;
console.log(name, age);

const arr = [1, 2, 3];
const [first, second] = arr;
  console.log(first, second);
  
В.9 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NureKulabukhovaTaisiia/ark-pzpi-23-10-kulabukhova-taisiia/blob/main/Pract1/ark-pzpi-23-10-Serhiehieva-Taisiia-pract1/code-examples-code-conventions.js
1
2
3
4
5try {
    JSON.parse("неправильний JSON");
} catch (error) {
    console.error("Помилка:", error.message);
}
В.10 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NureKulabukhovaTaisiia/ark-pzpi-23-10-kulabukhova-taisiia/blob/main/Pract1/ark-pzpi-23-10-Serhiehieva-Taisiia-pract1/code-examples-code-conventions.js
1
2
3
4
5
6
7
8
9/**
 * Функція обчислює площу прямокутника
 * @param {number} width - ширина
 * @param {number} height - висота
 * @returns {number} площа
 */
function rectangleArea(width, height) {
    return width * height;
}
В.11 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NureKulabukhovaTaisiia/ark-pzpi-23-10-kulabukhova-taisiia/blob/main/Pract1/ark-pzpi-23-10-Serhiehieva-Taisiia-pract1/code-examples-code-conventions.js
1
2
3
4
5
6
7//Погано
let discountedPrice1 = 500 * 0.4;

//Добре
const DISCOUNT_RATE = 0.4; // знижка 20%
let originalPrice = 500;
let discountedPrice2 = originalPrice * (1 - DISCOUNT_RATE);

В.12 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NureKulabukhovaTaisiia/ark-pzpi-23-10-kulabukhova-taisiia/blob/main/Pract1/ark-pzpi-23-10-Serhiehieva-Taisiia-pract1/code-examples-code-conventions.js
1
2
3
4
5
6
7
8
9async function fetchData() {
    try {
        let response = await fetch("https://api.example.com/data");
        let data = await response.json();
        console.log(data);
    } catch (error) {
        console.error("Помилка запиту:", error);
    }
}В.13 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NureKulabukhovaTaisiia/ark-pzpi-23-10-kulabukhova-taisiia/blob/main/Pract1/ark-pzpi-23-10-Serhiehieva-Taisiia-pract1/code-examples-code-conventions.js

 1
 2
 3
 4
 5
 6 // math.js
 export const add = (a, b) => a + b;
 
 // main.js
 import { add } from './math.js';
 console.log(add(5, 3));
В.14 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NureKulabukhovaTaisiia/ark-pzpi-23-10-kulabukhova-taisiia/blob/main/Pract1/ark-pzpi-23-10-Serhiehieva-Taisiia-pract1/code-examples-code-conventions.js
1
2
3
4
5
6const mySet = new Set([1, 2, 2, 3]);
console.log(mySet); // Set {1, 2, 3}

const myMap = new Map();
myMap.set("name", "Anna");
console.log(myMap.get("name")); // Anna
В.15 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NureKulabukhovaTaisiia/ark-pzpi-23-10-kulabukhova-taisiia/blob/main/Pract1/ark-pzpi-23-10-Serhiehieva-Taisiia-pract1/code-examples-code-conventions.js
1
2
3
4# Перевірка коду 
npx eslint script.js 
# Автоматичне форматування 
npx prettier --write script.js

В.16 Приклад оформлення програмного коду
GitHub репозиторій: https://github.com/NureKulabukhovaTaisiia/ark-pzpi-23-10-kulabukhova-taisiia/blob/main/Pract1/ark-pzpi-23-10-Serhiehieva-Taisiia-pract1/code-examples-code-conventions.js
1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21// Jest
test("додає два числа", () => {
    expect(2 + 3).toBe(5);
});

// Mocha
const assert = require("assert");

function multiply(a, b) {
    return a * b;
}

describe("multiply", function() {
    it("множить два додатних числа", function() {
        assert.strictEqual(multiply(2, 3), 6);
    });

    it("множить на нуль", function() {
        assert.strictEqual(multiply(5, 0), 0);
    });
});         


2


